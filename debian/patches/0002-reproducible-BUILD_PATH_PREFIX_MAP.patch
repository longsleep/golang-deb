Description: make builds reproducible by honoring BUILD_PATH_PREFIX_MAP
Forwarded: not-yet (waiting on gcc patch to be merged)
Author: Michael Stapelberg <stapelberg@debian.org>
Last-Update: 2017-08-25

---

--- a/src/cmd/go/internal/work/gc.go
+++ b/src/cmd/go/internal/work/gc.go
@@ -456,7 +456,10 @@
 		dir, out = filepath.Split(out)
 	}
 
-	return b.run(root, dir, root.Package.ImportPath, nil, cfg.BuildToolexec, base.Tool("link"), "-o", out, "-importcfg", importcfg, ldflags, mainpkg)
+	// Apply the rewrite of $WORK to /tmp/go-build also to DWARF file tables:
+	env := []string{"BUILD_PATH_PREFIX_MAP=/tmp/go-build=" + b.WorkDir + ":" + os.Getenv("BUILD_PATH_PREFIX_MAP")}
+
+	return b.run(root, dir, root.Package.ImportPath, env, cfg.BuildToolexec, base.Tool("link"), "-o", out, "-importcfg", importcfg, ldflags, mainpkg)
 }
 
 func (gcToolchain) ldShared(b *Builder, root *Action, toplevelactions []*Action, out, importcfg string, allactions []*Action) error {
--- /dev/null
+++ b/src/cmd/link/internal/ld/buildpathprefix.go
@@ -0,0 +1,56 @@
+// Copyright 2010 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package ld
+
+import (
+	"log"
+	"os"
+	"strings"
+	"sync"
+)
+
+func decode(s string) string {
+	s = strings.Replace(s, "%.", ":", -1)
+	s = strings.Replace(s, "%+", "=", -1)
+	s = strings.Replace(s, "%#", "%", -1)
+	return s
+}
+
+type prefixMapEntry struct {
+	target string
+	source string
+}
+
+var (
+	buildPathPrefixMap     []prefixMapEntry
+	buildPathPrefixMapOnce sync.Once
+)
+
+// See https://reproducible-builds.org/specs/build-path-prefix-map/
+func applyBuildPathPrefixMap(dir string) string {
+	// Parse the BUILD_PATH_PREFIX_MAP only once; this function gets called for
+	// every compiled file.
+	buildPathPrefixMapOnce.Do(func() {
+		for _, item := range strings.Split(os.Getenv("BUILD_PATH_PREFIX_MAP"), ":") {
+			if strings.TrimSpace(item) == "" {
+				continue
+			}
+			parts := strings.Split(item, "=")
+			if got, want := len(parts), 2; got != want {
+				log.Fatalf("parsing BUILD_PATH_PREFIX_MAP: incorrect number of = separators in item %q: got %d, want %d", item, got-1, want-1)
+			}
+			buildPathPrefixMap = append(buildPathPrefixMap, prefixMapEntry{
+				target: decode(parts[0]),
+				source: decode(parts[1]),
+			})
+		}
+	})
+	for _, e := range buildPathPrefixMap {
+		if strings.HasPrefix(dir, e.source) {
+			return e.target + strings.TrimPrefix(dir, e.source)
+		}
+	}
+	return dir
+}
--- a/src/cmd/link/internal/ld/dwarf.go
+++ b/src/cmd/link/internal/ld/dwarf.go
@@ -1131,7 +1131,7 @@
 	newattr(dwinfo, dwarf.DW_AT_language, dwarf.DW_CLS_CONSTANT, int64(lang), 0)
 	newattr(dwinfo, dwarf.DW_AT_stmt_list, dwarf.DW_CLS_PTR, ls.Size, ls)
 	// OS X linker requires compilation dir or absolute path in comp unit name to output debug info.
-	compDir := getCompilationDir()
+	compDir := applyBuildPathPrefixMap(getCompilationDir())
 	// TODO: Make this be the actual compilation directory, not
 	// the linker directory. If we move CU construction into the
 	// compiler, this should happen naturally.
@@ -1186,7 +1186,7 @@
 			}
 			// File indexes are 1-based.
 			fileNums[int(f.Value)] = len(fileNums) + 1
-			Addstring(ls, f.Name)
+			Addstring(ls, applyBuildPathPrefixMap(f.Name))
 			ls.AddUint8(0)
 			ls.AddUint8(0)
 			ls.AddUint8(0)
--- a/src/cmd/link/internal/ld/pcln.go
+++ b/src/cmd/link/internal/ld/pcln.go
@@ -301,7 +301,7 @@
 		off = int32(ftab.SetAddr(ctxt.Arch, int64(off), s))
 
 		// name int32
-		nameoff := nameToOffset(s.Name)
+		nameoff := nameToOffset(applyBuildPathPrefixMap(s.Name))
 		off = int32(ftab.SetUint32(ctxt.Arch, int64(off), uint32(nameoff)))
 
 		// args int32
@@ -411,7 +411,7 @@
 	ftab.SetUint32(ctxt.Arch, int64(start), uint32(len(ctxt.Filesyms)+1))
 	for i := len(ctxt.Filesyms) - 1; i >= 0; i-- {
 		s := ctxt.Filesyms[i]
-		ftab.SetUint32(ctxt.Arch, int64(start)+s.Value*4, uint32(ftabaddstring(ctxt, ftab, s.Name)))
+		ftab.SetUint32(ctxt.Arch, int64(start)+s.Value*4, uint32(ftabaddstring(ctxt, ftab, applyBuildPathPrefixMap(s.Name))))
 	}
 
 	ftab.Size = int64(len(ftab.P))
